{"version":3,"file":"index.js","mappings":"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","sources":["webpack://ato-mat-ic/webpack/universalModuleDefinition","webpack://ato-mat-ic/./lib/cli.ts","webpack://ato-mat-ic/./lib/generator.ts","webpack://ato-mat-ic/./lib/log.ts","webpack://ato-mat-ic/external commonjs \"args\"","webpack://ato-mat-ic/external commonjs \"mkdirp\"","webpack://ato-mat-ic/external commonjs \"npm-run\"","webpack://ato-mat-ic/external commonjs \"rimraf\"","webpack://ato-mat-ic/external commonjs \"tmp\"","webpack://ato-mat-ic/external commonjs \"winston\"","webpack://ato-mat-ic/external node-commonjs \"fs\"","webpack://ato-mat-ic/external node-commonjs \"path\"","webpack://ato-mat-ic/webpack/bootstrap","webpack://ato-mat-ic/./index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function() {\nreturn ","import * as args from 'args'\nimport * as path from 'path'\nimport {ELogLevel} from './log'\n\n/**\n * CLI argument names\n */\nexport enum ECliArgument {\n  /**\n   * Main file of non-bundled package source\n   */\n  entry = 'entry',\n\n  /**\n   * Root directory of targeted package\n   */\n  root = 'root',\n\n  /**\n   * Temporary directory required during generation\n   */\n  tmp = 'tmp',\n\n  /**\n   * Additional TSC properties\n   */\n  tsc = 'tsc',\n\n  /**\n   * Selected logging level\n   */\n  logLevel = 'logLevel',\n\n  /**\n   * Output file path (relative to root)\n   */\n  output = 'output',\n\n  /**\n   * Flag which forces using own TSC as opposed to target TSC\n   * This should only be used for testing npm-dts itself\n   * This is because it generates incorrect module names\n   */\n  testMode = 'testMode',\n}\n\n/**\n * Format for storing passed argument values\n */\nexport interface INpmDtsArgs {\n  /**\n   * Iterator\n   */\n  [argName: string]: string | boolean\n\n  /**\n   * Main file of non-bundled package source\n   */\n  entry?: string\n\n  /**\n   * Root directory of targeted package\n   */\n  root?: string\n\n  /**\n   * Temporary directory required during generation\n   */\n  tmp?: string\n\n  /**\n   * Additional TSC properties\n   */\n  tsc?: string\n\n  /**\n   * Selected logging level\n   */\n  logLevel?: ELogLevel\n\n  /**\n   * Output file path (relative to root)\n   */\n  output?: string\n\n  /**\n   * Flag which forces using own TSC as opposed to target TSC\n   * This should only be used for testing npm-dts itself\n   * This is because it generates incorrect module names\n   */\n  testMode?: boolean\n}\n\n/**\n * CLI usage logic\n */\nexport class Cli {\n  /**\n   * Stores whether module was successfully launched\n   */\n  protected launched = false\n\n  /**\n   * Stores whether TMP directory location was passed\n   */\n  protected tmpPassed = false\n\n  /**\n   * Stores current CLI argument values\n   */\n  private args: INpmDtsArgs = {\n    entry: 'index.ts',\n    root: path.resolve(process.cwd()),\n    tmp: path.resolve(process.cwd(), '.atomic'),\n    tsc: '',\n    logLevel: ELogLevel.info,\n    output: 'index.d.ts',\n    testMode: false,\n  }\n\n  /**\n   * Automatically reads CLI arguments and performs actions based on them\n   */\n  public constructor(injectedArguments?: INpmDtsArgs) {\n    if (injectedArguments) {\n      this.launched = true\n      this.storeArguments(injectedArguments)\n    } else {\n      args\n        .option(\n          ['e', 'entry'],\n          'Entry/main package file before bundling, relative to project root',\n        )\n        .option(\n          ['r', 'root'],\n          'NPM package directory containing package.json',\n          this.args.root,\n        )\n        .option(\n          ['t', 'tmp'],\n          'Directory for storing temporary information',\n          this.args.tmp,\n          (value: string) => {\n            if (!value.includes('<')) {\n              this.tmpPassed = true\n            }\n\n            return value\n          },\n        )\n        .option(\n          ['c', 'tsc'],\n          'Passed through non-validated additional TSC options',\n          this.args.tsc,\n        )\n        .option(\n          ['L', 'logLevel'],\n          'Log level (error, warn, info, verbose, debug)',\n          this.args.logLevel,\n        )\n        .option(\n          ['o', 'output'],\n          'Overrides recommended output target to a custom one',\n          this.args.output,\n        )\n        .option(\n          ['m', 'testMode'],\n          'Configures ato-mat-ic for self-test',\n          this.args.testMode,\n        )\n        .command('generate', 'Start generation', (name, sub, options) => {\n          this.launched = true\n          this.storeArguments(options)\n        })\n        .example(\n          'ato-mat-ic generate',\n          'Generates index.d.ts file and updates package.json for CWD.',\n        )\n        .example(\n          'ato-mat-ic -r /your/project/path generate',\n          'Performs generation on a custom path.',\n        )\n\n      args.parse(process.argv, {\n        name: 'ato-mat-ic',\n        mri: {},\n        mainColor: 'yellow',\n        subColor: 'dim',\n      })\n\n      if (!this.launched) {\n        args.showHelp()\n      }\n    }\n  }\n\n  /**\n   * Gathers current value of a particular CLI argument\n   * @param arg argument name\n   */\n  protected getArgument(arg: ECliArgument) {\n    return this.args[arg]\n  }\n\n  /**\n   * Dynamically overrides value of stored argument\n   * @param arg argument name\n   * @param value argument value\n   */\n  protected setArgument(arg: ECliArgument, value: string | boolean) {\n    // @ts-ignore\n    this.args[arg] = value\n  }\n\n  /**\n   * Stores entered CLI arguments\n   * @param passedArguments arguments entered to CLI\n   */\n  private storeArguments(passedArguments: any = this.args) {\n    for (const argName of Object.keys(this.args)) {\n      this.args[argName] = Object.is(passedArguments[argName], undefined)\n        ? this.args[argName]\n        : passedArguments[argName]\n    }\n  }\n}\n","import {readdirSync, statSync, writeFileSync} from 'fs'\nimport {readFileSync} from 'fs'\nimport * as mkdir from 'mkdirp'\nimport * as npmRun from 'npm-run'\nimport {join, relative, resolve, dirname} from 'path'\nimport * as rm from 'rimraf'\nimport * as tmp from 'tmp'\nimport {Cli, ECliArgument, INpmDtsArgs} from './cli'\nimport {debug, ELogLevel, error, info, init, verbose, warn} from './log'\nimport * as fs from 'fs'\n\nconst MKDIR_RETRIES = 5\n\n/**\n * Logic for generating aggregated typings for NPM module\n */\n export class Generator extends Cli {\n  private packageInfo: any\n  private moduleNames: string[]\n  private throwErrors: boolean\n  private cacheContentEmptied: boolean = true\n\n  /**\n   * Auto-launches generation based on command line arguments\n   * @param injectedArguments generation arguments (same as CLI)\n   * @param enableLog enables logging when true, null allows application to decide\n   * @param throwErrors makes generation throw errors when true\n   */\n  public constructor(\n    injectedArguments?: INpmDtsArgs,\n    enableLog: boolean | null = null,\n    throwErrors = false,\n  ) {\n    super(injectedArguments)\n\n    this.throwErrors = throwErrors\n\n    if (enableLog === null) {\n      enableLog = !injectedArguments\n    }\n\n    if (enableLog) {\n      const myPackageJson = JSON.parse(\n        readFileSync(resolve(__dirname, '..', 'package.json'), {\n          encoding: 'utf8',\n        }),\n      )\n\n      init(myPackageJson.name, this.getLogLevel())\n      info(`${myPackageJson.name} v${myPackageJson.version}`)\n    }\n  }\n\n  /**\n   * Executes generation of single declaration file\n   */\n  public async generate() {\n    info(`Generating declarations for \"${this.getRoot()}\"...`)\n\n    let hasError = false\n    let exception = null\n    const cleanupTasks: (() => void)[] = []\n\n    if (!this.tmpPassed) {\n      verbose('Locating OS Temporary Directory...')\n\n      try {\n        await new Promise<void>(done => {\n          tmp.dir((tmpErr, tmpDir, rmTmp) => {\n            if (tmpErr) {\n              error('Could not create OS Temporary Directory!')\n              this.showDebugError(tmpErr)\n              throw tmpErr\n            }\n\n            verbose('OS Temporary Directory was located!')\n            this.setArgument(ECliArgument.tmp, resolve(tmpDir, 'npm-dts'))\n\n            cleanupTasks.push(() => {\n              verbose('Deleting OS Temporary Directory...')\n              rmTmp()\n              verbose('OS Temporary Directory was deleted!')\n            })\n            done()\n          })\n        })\n      } catch (e) {\n        hasError = true\n        exception = e\n      }\n    }\n\n    if (!hasError) {\n      await this._generate().catch(async e => {\n        hasError = true\n\n        const output = this.getOutput()\n\n        error(`Generation of ${output} has failed!`)\n        this.showDebugError(e)\n\n        if (!this.cacheContentEmptied) {\n          await this.clearTempDir()\n        }\n\n        exception = e\n      })\n    }\n\n    cleanupTasks.forEach(task => task())\n\n    if (!hasError) {\n      info('Generation is completed!')\n    } else {\n      error('Generation failed!')\n\n      if (this.throwErrors) {\n        throw exception || new Error('Generation failed!')\n      }\n    }\n  }\n\n  /**\n   * Launches generation of typings\n   */\n   private async _generate() {\n    await this.generateTypings()\n    const source = await this.combineTypings()\n    await this.storeResult(source)\n  }\n\n  /**\n   * Logs serialized error if it exists\n   * @param e - error to be shown\n   */\n   private showDebugError(e: any) {\n    if (e) {\n      if (e.stdout) {\n        debug(`Error: \\n${e.stdout.toString()}`)\n      } else {\n        debug(`Error: \\n${JSON.stringify(e)}`)\n      }\n    }\n  }\n\n  private getLogLevel(): ELogLevel {\n    const logLevel = this.getArgument(ECliArgument.logLevel) as ELogLevel\n    return ELogLevel[logLevel] ? logLevel : ELogLevel.info\n  }\n\n  /**\n   * Gathers entry file address (relative to project root path)\n   */\n  private getEntry(): string {\n    return this.getArgument(ECliArgument.entry) as string\n  }\n\n  /**\n   * Gathers target project root path\n   */\n  private getRoot(): string {\n    return resolve(this.getArgument(ECliArgument.root) as string)\n  }\n\n  /**\n   * Gathers TMP directory to be used for TSC operations\n   */\n  private getTempDir(): string {\n    return resolve(this.getArgument(ECliArgument.tmp) as string)\n  }\n\n  /**\n   * Gathers output path to be used (relative to root)\n   */\n  private getOutput(): string {\n    return this.getArgument(ECliArgument.output) as string\n  }\n\n  /**\n   * Checks if script is forced to use its built-in TSC\n   */\n  private useTestMode(): boolean {\n    return this.getArgument(ECliArgument.testMode) as boolean\n  }\n\n  /**\n   * Creates TMP directory to be used for TSC operations\n   * @param retries amount of times to retry on failure\n   */\n   private makeTempDir(retries = MKDIR_RETRIES): Promise<void> {\n    const tmpDir = this.getTempDir()\n    verbose('Preparing \"tmp\" directory...')\n\n    return new Promise((done, fail) => {\n      mkdir(tmpDir)\n        .then(() => {\n          this.cacheContentEmptied = false\n          verbose('\"tmp\" directory was prepared!')\n          done()\n        })\n        .catch(mkdirError => {\n          error(`Failed to create \"${tmpDir}\"!`)\n          this.showDebugError(mkdirError)\n\n          if (retries) {\n            const sleepTime = 100\n            verbose(`Will retry in ${sleepTime}ms...`)\n\n            setTimeout(() => {\n              this.makeTempDir(retries - 1).then(done, fail)\n            }, sleepTime)\n          } else {\n            error(`Stopped trying after ${MKDIR_RETRIES} retries!`)\n            fail()\n          }\n        })\n    })\n  }\n\n  /**\n   * Removes TMP directory\n   */\n  private clearTempDir() {\n    const tmpDir = this.getTempDir()\n    verbose('Cleaning up \"tmp\" directory...')\n\n    return new Promise<void>((done, fail) => {\n      rm(tmpDir, rmError => {\n        if (rmError) {\n          error(`Could not clean up \"tmp\" directory at \"${tmpDir}\"!`)\n          this.showDebugError(rmError)\n          fail()\n        } else {\n          this.cacheContentEmptied = true\n          verbose('\"tmp\" directory was cleaned!')\n          done()\n        }\n      })\n    })\n  }\n\n  /**\n   * Re-creates empty TMP directory to be used for TSC operations\n   */\n   private resetCacheDir() {\n    verbose('Will now reset \"tmp\" directory...')\n    return new Promise((done, fail) => {\n      this.clearTempDir().then(() => {\n        this.makeTempDir().then(done, fail)\n      }, fail)\n    })\n  }\n\n  /**\n   * Generates per-file typings using TSC\n   */\n  private async generateTypings() {\n    await this.resetCacheDir()\n\n    verbose('Generating per-file typings using TSC...')\n\n    const tscOptions = this.getArgument(ECliArgument.tsc) as string\n\n    const cmd =\n      'tsc --declaration --emitDeclarationOnly --declarationDir \"' +\n      this.getTempDir() +\n      '\"' +\n      (tscOptions.length ? ` ${tscOptions}` : '')\n\n    debug(cmd)\n\n    try {\n      npmRun.execSync(\n        cmd,\n        {\n          cwd: this.useTestMode() ? resolve(__dirname, '..') : this.getRoot(),\n        },\n        (err: any, stdout: any, stderr: any) => {\n          if (err) {\n            error('TSC exited with errors!')\n\n            this.showDebugError(err)\n          } else {\n            if (stdout) {\n              process.stdout.write(stdout)\n            }\n\n            if (stderr) {\n              process.stderr.write(stderr)\n            }\n          }\n        },\n      )\n    } catch (e) {\n      throw e\n    }\n\n    verbose('Per-file typings have been generated using TSC!')\n  }\n\n  /**\n   * Loads generated per-file declaration files\n   */\n   private loadTypings() {\n    const result: IDeclarationMap = {}\n\n    const declarationFiles = this.getDeclarationFiles()\n\n    verbose('Loading declaration files and mapping to modules...')\n    declarationFiles.forEach(file => {\n      const moduleName = this.convertPathToModule(file)\n\n      try {\n        result[moduleName] = readFileSync(file, {encoding: 'utf8'})\n      } catch (e) {\n        error(`Could not load declaration file '${file}'!`)\n        this.showDebugError(e)\n        throw e\n      }\n    })\n\n    verbose('Loaded declaration files and mapped to modules!')\n    return result\n  }\n\n  /**\n   * Combines typings into a single declaration source\n   */\n  private async combineTypings() {\n    const typings = this.loadTypings()\n    await this.clearTempDir()\n\n    this.moduleNames = Object.keys(typings)\n\n    verbose('Combining typings into single file...')\n\n    const sourceParts: string[] = [\n      '// Auto generated by ato-mat-ic\\n'\n    ]\n\n    sourceParts.push('declare module \"@components\" {')\n\n    Object.entries(typings).forEach(([moduleName, fileSource]) => {\n      moduleName = moduleName.replace(/^([^/]+)\\/index/, '$1')\n      fileSource = fileSource.replace(/declare /g, '')\n      fileSource = this.resolveImportSources(fileSource, moduleName)\n      verbose(`Adding ${moduleName}`)\n      sourceParts.push(\n        `\\n${(fileSource as string).replace(\n          /^./gm,\n          '  $&',\n        ).replace(new RegExp(`export default ${moduleName}`, 'g'), `export { ${moduleName} }`)}`,\n      )\n    })\n    sourceParts.push('}')\n\n    verbose('Combined typings into a single file!')\n    return sourceParts.join('\\n')\n  }\n\n  private resolveImportSourcesAtLine(\n    regexp: RegExp,\n    line: string,\n    moduleName: string,\n  ) {\n    const matches = line.match(regexp)\n\n    if (matches && matches[2].startsWith('.')) {\n      const relativePath = `../${matches[2]}`\n\n      let resolvedModule = resolve(moduleName, relativePath)\n\n      resolvedModule = this.convertPathToModule(resolvedModule, {\n        rootType: IBasePathType.cwd,\n        noPrefix: true,\n        noExtensionRemoval: true,\n      })\n\n      if (!this.moduleExists(resolvedModule)) {\n        resolvedModule += '/index'\n      }\n\n      line = line.replace(regexp, `$1${resolvedModule}$3`)\n    }\n\n    return line\n  }\n\n  /**\n   * Verifies if module specified exists among known modules\n   * @param moduleName name of module to be checked\n   */\n  private moduleExists(moduleName: string) {\n    return this.moduleNames.includes(moduleName)\n  }\n\n  /**\n   * Alters import sources to avoid relative addresses and default index usage\n   * @param source import source to be resolved\n   * @param moduleName name of module containing import\n   */\n  private resolveImportSources(source: string, moduleName: string) {\n    source = source.replace(/\\r\\n/g, '\\n')\n    source = source.replace(/\\n\\r/g, '\\n')\n    source = source.replace(/\\r/g, '\\n')\n\n    let lines = source.split('\\n')\n\n    lines = lines.map(line => {\n      line = this.resolveImportSourcesAtLine(\n        /(from ['\"])([^'\"]+)(['\"])/,\n        line,\n        moduleName,\n      )\n\n      line = this.resolveImportSourcesAtLine(\n        /(import\\(['\"])([^'\"]+)(['\"]\\))/,\n        line,\n        moduleName,\n      )\n\n      return line\n    })\n\n    source = lines.join('\\n')\n\n    return source\n  }\n\n  /**\n   * Gathers a list of created per-file declaration files\n   * @param dir directory to be scanned for files (called during recursion)\n   * @param files discovered array of files (called during recursion)\n   */\n   private getDeclarationFiles(\n    dir: string = this.getTempDir(),\n    files: string[] = [],\n  ) {\n    if (dir === this.getTempDir()) {\n      verbose('Loading list of generated typing files...')\n    }\n\n    try {\n      readdirSync(dir).forEach(file => {\n        if (statSync(join(dir, file)).isDirectory()) {\n          files = this.getDeclarationFiles(join(dir, file), files)\n        } else {\n          files = files.concat(join(dir, file))\n        }\n      })\n    } catch (e) {\n      error('Failed to load list of generated typing files...')\n      this.showDebugError(e)\n      throw e\n    }\n\n    if (dir === this.getTempDir()) {\n      verbose('Successfully loaded list of generated typing files!')\n    }\n\n    return files\n  }\n\n  /**\n   * Generates module name based on file path\n   * @param path path to be converted to module name\n   * @param options additional conversion options\n   */\n   private convertPathToModule(\n    path: string,\n    options: ConvertPathToModuleOptions = {},\n  ) {\n    const {\n      rootType = IBasePathType.tmp,\n      noExtensionRemoval = false,\n      noExistenceCheck = false,\n    } = options\n\n    const fileExisted =\n      noExistenceCheck ||\n      (!noExtensionRemoval &&\n        fs.existsSync(path) &&\n        fs.lstatSync(path).isFile())\n\n    if (rootType === IBasePathType.cwd) {\n      path = relative(process.cwd(), path)\n    } else if (rootType === IBasePathType.root) {\n      path = relative(this.getRoot(), path)\n    } else if (rootType === IBasePathType.tmp) {\n      path = relative(this.getTempDir(), path)\n    }\n\n    path = path.replace(/\\\\/g, '/')\n\n    if (fileExisted && !noExtensionRemoval) {\n      path = path.replace(/\\.[^.]+$/g, '')\n      path = path.replace(/\\.d$/g, '')\n    }\n\n    return path\n  }\n\n  /**\n   * Stores generated .d.ts declaration source into file\n   * @param source generated .d.ts source\n   */\n  private async storeResult(source: string) {\n    const output = this.getOutput()\n    const root = this.getRoot()\n    const file = resolve(root, output)\n    const folderPath = dirname(file)\n\n    verbose('Ensuring that output folder exists...')\n    debug(`Creating output folder: \"${folderPath}\"...`)\n\n    try {\n      await mkdir(folderPath)\n    } catch (mkdirError) {\n      error(`Failed to create \"${folderPath}\"!`)\n      this.showDebugError(mkdirError)\n      throw mkdirError\n    }\n\n    verbose('Output folder is ready!')\n    verbose(`Storing typings into ${output} file...`)\n\n    try {\n      writeFileSync(file, source, {encoding: 'utf8'})\n    } catch (e) {\n      error(`Failed to create ${output}!`)\n      this.showDebugError(e)\n      throw e\n    }\n\n    verbose(`Successfully created ${output} file!`)\n  }\n}\n\n/**\n * Map of modules and their declarations\n */\n export interface IDeclarationMap {\n  [moduleNames: string]: string\n}\n\n/**\n * Types of base path used during path resolving\n */\nexport enum IBasePathType {\n  /**\n   * Base path is root of targeted project\n   */\n  root = 'root',\n\n  /**\n   * Base path is tmp directory\n   */\n  tmp = 'tmp',\n\n  /**\n   * Base path is CWD\n   */\n  cwd = 'cwd',\n}\n\n/**\n * Additional conversion options\n */\nexport interface ConvertPathToModuleOptions {\n  /**\n   * Type of base path used during path resolving\n   */\n  rootType?: IBasePathType\n\n  /**\n   * Disables addition of module name as prefix for module name\n   */\n  noPrefix?: boolean\n\n  /**\n   * Disables extension removal\n   */\n  noExtensionRemoval?: boolean\n\n  /**\n   * Disables existence check and assumes that file exists\n   */\n  noExistenceCheck?: boolean\n}\n","import * as winston from 'winston'\nimport {\n  debug as winstonDebug,\n  error as winstonError,\n  info as winstonInfo,\n  silly as winstonSilly,\n  verbose as winstonVerbose,\n  warn as winstonWarn,\n} from 'winston'\n\nwinston.addColors({\n  error: 'red',\n  warn: 'yellow',\n  info: 'cyan',\n  debug: 'green',\n})\n\nlet logEnabled = false\n\n/**\n * Supported debug levels\n */\nexport enum ELogLevel {\n  /**\n   * Error\n   */\n  error = 'error',\n\n  /**\n   * Warning\n   */\n  warn = 'warn',\n\n  /**\n   * Information\n   */\n  info = 'info',\n\n  /**\n   * Verbose information\n   */\n  verbose = 'verbose',\n\n  /**\n   * Debug information\n   */\n  debug = 'debug',\n}\n\n/**\n * Logs error message\n * @param message Message to be logged\n */\nexport const error = (message: string) => {\n  if (logEnabled) {\n    return winstonError(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs warning message\n * @param message Message to be logged\n */\nexport const warn = (message: string) => {\n  if (logEnabled) {\n    return winstonWarn(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs informational message\n * @param message Message to be logged\n */\nexport const info = (message: string) => {\n  if (logEnabled) {\n    return winstonInfo(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs verbose message\n * @param message Message to be logged\n */\nexport const verbose = (message: string) => {\n  if (logEnabled) {\n    return winstonVerbose(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs debug message\n * @param message Message to be logged\n */\nexport const debug = (message: string) => {\n  if (logEnabled) {\n    return winstonDebug(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Initializes and enables logging\n * @param label prefix to be used before each log line\n */\nexport const init = (label: string, level: ELogLevel) => {\n  winston.configure({\n    level,\n    format: winston.format.combine(\n      winston.format.colorize(),\n      winston.format.label({label}),\n      winston.format.timestamp(),\n      winston.format.prettyPrint(),\n      winston.format.printf(\n        (parts: any) => `[${parts.label}] [${parts.level}] : ${parts.message}`,\n      ),\n    ),\n    transports: [new winston.transports.Console()],\n  })\n\n  logEnabled = true\n}\n","module.exports = require(\"args\");","module.exports = require(\"mkdirp\");","module.exports = require(\"npm-run\");","module.exports = require(\"rimraf\");","module.exports = require(\"tmp\");","module.exports = require(\"winston\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export {Generator} from './lib/generator'\n"],"names":["root","factory","exports","module","define","amd","a","i","global","ECliArgument","injectedArguments","launched","tmpPassed","args","entry","path","resolve","process","cwd","tmp","tsc","logLevel","ELogLevel","info","output","testMode","this","storeArguments","option","value","includes","command","name","sub","options","example","parse","argv","mri","mainColor","subColor","showHelp","getArgument","arg","setArgument","passedArguments","Object","keys","argName","is","undefined","Cli","IBasePathType","enableLog","throwErrors","cacheContentEmptied","myPackageJson","JSON","readFileSync","__dirname","encoding","init","getLogLevel","version","generate","getRoot","hasError","exception","cleanupTasks","verbose","Promise","done","dir","tmpErr","tmpDir","rmTmp","error","showDebugError","push","_generate","catch","e","getOutput","clearTempDir","forEach","task","Error","generateTypings","combineTypings","source","storeResult","stdout","debug","toString","stringify","getEntry","getTempDir","useTestMode","makeTempDir","retries","fail","mkdir","then","mkdirError","setTimeout","rm","rmError","resetCacheDir","tscOptions","cmd","length","npmRun","execSync","err","stderr","write","loadTypings","result","declarationFiles","getDeclarationFiles","file","moduleName","convertPathToModule","typings","moduleNames","sourceParts","entries","fileSource","replace","resolveImportSources","RegExp","join","resolveImportSourcesAtLine","regexp","line","matches","match","startsWith","relativePath","resolvedModule","rootType","noPrefix","noExtensionRemoval","moduleExists","lines","split","map","files","readdirSync","statSync","isDirectory","concat","fileExisted","fs","existsSync","lstatSync","isFile","relative","folderPath","dirname","writeFileSync","Generator","winston","addColors","warn","logEnabled","message","label","level","configure","format","combine","colorize","timestamp","prettyPrint","printf","parts","transports","Console","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}